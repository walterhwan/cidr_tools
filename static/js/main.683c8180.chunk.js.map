{"version":3,"sources":["netmask46.js","CidrRange.js","BinaryExplained.js","App.js","serviceWorker.js","index.js"],"names":["long2ip","long","join","ip2long","ip","b","split","length","Error","i","byte","isNaN","parseInt","Netmask4","netmask","this","bitmask","maskLong","netLong","err","cidr","size","Math","pow","hostmask","first","last","indexOf","contains","base","count","fn","lastLong","index","CidrRange","ipRangeData","className","Object","entries","map","key","val","BinaryExplained","binaryData","decimalToBinary","dec","Number","toString","padStart","ipv4ToBinary","App","React","useState","inputBox","setInputBox","setCidr","errorText","setErrorText","errorCallBack","block","errorMessage","message","cidrToDisplay","autoFocus","type","value","onChange","event","target","ipRegex","exact","test","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console"],"mappings":"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","file":"static/js/main.683c8180.chunk.js","sourcesContent":["const long2ip = function(long) {\n  const a = (long & (0xff << 24)) >>> 24\n  const b = (long & (0xff << 16)) >>> 16\n  const c = (long & (0xff << 8)) >>> 8\n  const d = long & 0xff\n  return [a, b, c, d].join('.')\n}\n\nconst ip2long = function(ip) {\n  const b = ip.split('.')\n  if (b.length === 0 || b.length > 4) {\n    throw new Error('Invalid IP')\n  }\n  for (let i = 0; i < b.length; i++) {\n    const byte = b[i]\n    if (isNaN(parseInt(byte, 10))) {\n      throw new Error(`Invalid byte: ${byte}`)\n    }\n    if (byte < 0 || byte > 255) {\n      throw new Error(`Invalid byte: ${byte}`)\n    }\n  }\n  return ((b[0] << 24) | (b[1] << 16) | (b[2] << 8) | b[3]) >>> 0\n}\n\nexport class Netmask4 {\n  // input can be new Netmask4('10.0.0.1/32') or Netmask4('10.0.0.1', '32')\n  constructor(ip, netmask) {\n    if (typeof ip !== 'string') {\n      throw new Error('Missing ip')\n    }\n    if (!netmask) {\n      ;[ip, netmask] = ip.split('/', 2)\n    }\n    if (!netmask) {\n      throw new Error(`Invalid ip address: ${ip}`)\n    }\n\n    if (netmask) {\n      this.bitmask = parseInt(netmask, 10)\n      this.maskLong = 0\n      if (this.bitmask > 0) {\n        this.maskLong = (0xffffffff << (32 - this.bitmask)) >>> 0\n      }\n    } else {\n      throw new Error('Invalid netmask: empty')\n    }\n    \n    if (isNaN(this.bitmask) || this.bitmask > 32 || this.bitmask < 0) {\n      throw new Error(`Invalid netmask: ${netmask}`)\n    }\n\n    try {\n      this.netLong = (ip2long(ip) & this.maskLong) >>> 0\n    } catch (err) {\n      throw new Error(`Invalid ip address: ${ip}`)\n    }\n\n    this.ip = ip\n    this.cidr = `${ip}/${this.bitmask}`\n    this.size = Math.pow(2, 32 - this.bitmask)\n    this.netmask = long2ip(this.maskLong)\n\n    // The host netmask, the opposite of the netmask (eg.: 0.0.0.255)\n    this.hostmask = long2ip(~this.maskLong)\n\n    this.first = long2ip(this.netLong)\n    this.last = long2ip(this.netLong + this.size - 1)\n  }\n\n  contains(ip) {\n    if (\n      typeof ip === 'string' &&\n      (ip.indexOf('/') > 0 || ip.split('.').length !== 4)\n    ) {\n      ip = new Netmask4(ip)\n    }\n\n    if (ip instanceof Netmask4) {\n      return this.contains(ip.base) && this.contains(ip.last)\n    } else {\n      return (\n        (ip2long(ip) & this.maskLong) >>> 0 ===\n        (this.netLong & this.maskLong) >>> 0\n      )\n    }\n  }\n\n  next(count) {\n    if (count == null) {\n      count = 1\n    }\n    return new Netmask4(\n      long2ip(this.netLong + this.size * count),\n      this.bitmask\n    )\n  }\n\n  forEach(fn) {\n    let long = ip2long(this.first)\n    const lastLong = ip2long(this.last)\n    let index = 0\n    while (long <= lastLong) {\n      fn(long2ip(long), long, index)\n      index++\n      long++\n    }\n  }\n\n  toString() {\n    return this.first + '/' + this.bitmask\n  }\n}\n\n// exports.ip2long = ip2long\n// exports.long2ip = long2ip\n// exports.Netmask4 = Netmask4\n\n// class Netmask6 {\n//   constructor(ipv6, netmask) {\n//     if (typeof ipv6 !== 'string') {\n//       throw new Error('Missing ip')\n//     }\n//     if (!netmask) {\n//       ;[ipv6, netmask] = ipv6.split('/', 2)\n//     }\n//     if (!netmask) {\n//       throw new Error(`Invalid ip address: ${ipv6}`)\n//     }\n\n//     this.cidr = `${ipv6}/${netmask}`\n//   }\n// }\n","import React from 'react'\nimport PropTypes from 'prop-types'\n\n\nexport default function CidrRange({ ipRangeData = {} }) {\n  return (\n    <div className=\"cidr-output\">\n      {Object.entries(ipRangeData).map(([key, val]) => (\n        <div className=\"output-row\" key={key}>\n          <div className=\"output-left\">{`${key}:`}</div>\n          <div className=\"output-right\">{val}</div>\n        </div>\n      ))}\n    </div>\n  )\n}\nCidrRange.propTypes = {\n  ipRangeData: PropTypes.object,\n}\n","import React from 'react'\nimport PropTypes from 'prop-types'\n\n\nexport default function BinaryExplained({ binaryData = {} }) {\n  return (\n    <>\n      <div className=\"title\">\n        <p>In Binary</p>\n      </div>\n      <div className=\"cidr-output\">\n        {Object.entries(binaryData).map(([key, val]) => (\n          <div className=\"output-row\" key={key}>\n            <div className=\"output-left\">{`${key}:`}</div>\n            <div className=\"output-binary-right\">{val}</div>\n          </div>\n        ))}\n      </div>\n      <div className=\"cidr-output\">\n        <p>{'<Base IP> BITWISE AND <Net Mask> = <First IP>'}</p>\n        <p>{'<First IP> BITWISE OR <Host Mask> = <Last IP>'}</p>\n      </div>\n    </>\n  )\n}\nBinaryExplained.propTypes = {\n  binaryData: PropTypes.object,\n}","import React from 'react'\nimport ipRegex from 'ip-regex'\n\nimport { Netmask4 } from './netmask46'\nimport CidrRange from './CidrRange'\nimport BinaryExplained from './BinaryExplained'\n\nimport './App.css'\n\nconst DEFAULT_CIDR = '192.168.0.37/30'\n\nfunction decimalToBinary(dec) {\n  return Number(dec)\n    .toString(2)\n    .padStart(8, '0')\n}\n\nfunction ipv4ToBinary(ip) {\n  return ip\n    .split('.')\n    .map(decimalToBinary)\n    .join(' ')\n}\n\nfunction cidrToDisplay(cidr, errorCallBack) {\n  let block\n  let errorMessage\n  if (cidr) {\n    try {\n      block = new Netmask4(cidr)\n    } catch (err) {\n      errorMessage = err.message\n      errorCallBack(err)\n    }\n  }\n  if (block) {\n    return {\n      ipRangeData: {\n        'CIDR Range': block.cidr,\n        'Net Mask': block.netmask,\n        'Host Mask': block.hostmask,\n        'First IP': block.first,\n        'Last IP': block.last,\n        'Total Hosts': block.size,\n      },\n      binaryData: {\n        'Base IP': ipv4ToBinary(block.ip),\n        'Net Mask': ipv4ToBinary(block.netmask),\n        'First IP': ipv4ToBinary(block.first),\n        'Host Mask': ipv4ToBinary(block.hostmask),\n        'Last IP': ipv4ToBinary(block.last),\n      },\n    }\n  }\n  return {\n    ipRangeData: {},\n    binaryData: {},\n    errorMessage,\n  }\n}\n\nfunction App() {\n  const [inputBox, setInputBox] = React.useState(DEFAULT_CIDR)\n  const [cidr, setCidr] = React.useState(inputBox)\n  const [errorText, setErrorText] = React.useState('')\n\n  const handleChange = (event) => {\n    const value = event.target.value\n    const [ip, bitmask] = value.split('/')\n    const isIpv4 = ipRegex({ exact: true }).test(ip)\n\n    if (isIpv4 && bitmask) setCidr(value)\n    else setCidr()\n\n    setInputBox(value)\n    setErrorText('')\n  }\n\n  const handleError = (err) => {\n    setCidr()\n    setErrorText(err.message)\n  }\n\n  const { ipRangeData, binaryData } = cidrToDisplay(cidr, handleError)\n\n  return (\n    <div className=\"App\">\n      {/* Title */}\n      <div className=\"title\">\n        <p>CIDR To IP Range Explained</p>\n      </div>\n      {/* IP Input */}\n      <input\n        className=\"cidr-input\"\n        autoFocus\n        type=\"text\"\n        value={inputBox}\n        onChange={handleChange}\n      />\n      {/* Data/Error */}\n      {!cidr ? (\n        <div className=\"cidr-error\">\n          <p>{errorText}</p>\n        </div>\n      ) : (\n        <>\n          <CidrRange {...{ ipRangeData }} />\n          <BinaryExplained {...{ binaryData }} />\n        </>\n      )}\n    </div>\n  )\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}